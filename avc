#!/usr/bin/env bash
#
# avc - aggregated vcs
#
# 

#
# avc specfile example
#
##
# custom development env setup
#
#
# cboom	 ref	branches/goo
# kuwaka ref	trunk
# boost  ref     boost-1.4.6
# 
# boost	url	git+ssh://git@git.foo.org/boost
# cboom	url	svn+https://svn.foo.org/svn/repo/cboom
#       
# will checkout
#  cboom  -> svn+https://svn.foo.org/svn/repo/cboom/branches/foo
#  kuwaka -> svn+https://svn.foo.org/svn/repo/kuwaka/trunk
#  boost  -> git+ssh://git@git.foo.org/boost && checkout boost-1.4.6
#


#DRY_RUN=1
#QUIET=1

#
# git
#

git_checkout()
{
    local target_folder="$1"
    local clone_url="$2"
    local ref="$3"
    if [ ! -d "$target_folder" ] ; then
        run_in .                git clone "$clone_url" "$target_folder"
    else
        run_in $target_folder   git fetch
    fi
    run_in "$target_folder" git checkout $ref
        
}
git_search_worskpaces()
{
    find . -name ".git" | xargs --no-run-if-empty --max-args=1 dirname
}

git_unknown_files() 
{
    run_in $1 git status --porcelain | egrep '^\?\?' | wc -l
}

git_modified_elements() 
{
    run_in $1 git status --porcelain | egrep -v '^\?\?' | wc -l
}

git_content_tag()
{
    local branch=`run_in $1 git branch`
    if echo "$branch" | grep -qF "(no branch)" ; then
        run_in "$1" git describe 2>/dev/null
    else
        echo "$branch" | awk '/\*/ {print $2;}'
    fi
}

git_status()
{
    local workspace_dir="$1"
    shift
    
    run_in "$workspace_dir" git status -s  "$@" | awk -v root=$workspace_dir '{printf("%s %s/%s\n", $1, root, $2)}'
}

git_workspace_diff()
{
    local workspace_dir="$1"
    shift
    
    run_in "$workspace_dir" git diff --src-prefix=$workspace_dir/ --dst-prefix=$workspace_dir/ "$@" | cat  
}

git_remove()
{
    local workspace_dir="$1"
    shift
    
    run_in "$workspace_dir" git rm "$@" 
}

git_commit()
{
    local workspace_dir="$1"
    shift
    local git_commit_options=""
    if [ -n "$commit_message" ] ; then
        git_commit_options="-m \"$commit_message\""
    fi
    run_in "$workspace_dir" git commit $git_commit_options "$@"
}
#
# mtn
#

mtn_checkout()
{
    local target_folder="$1"
    local db_name="$(dirname $target_folder)/.$(basename $target_folder).mtn"
    local clone_url="$2"
    local ref="$3"
    
    if [ ! -f "$db_name" ] ; then
        run_in . mtn db init -d "$db_name"
    fi
    run_in . mtn pull -d "$db_name" "$clone_url"
    
    if [ ! -d "$target_folder" ] ; then
        run_in . mtn -d "$db_name" checkout --revision="$ref" "$target_folder"
    else
        run_in "$target_folder" mtn update --revision=$ref
    fi
}
mtn_search_workspaces()
{
    find . -name "_MTN" | xargs --no-run-if-empty  --max-args=1 dirname
}

mtn_unknown_files()
{
    run_in $1 mtn ls unknown | wc -l
}

mtn_modified_elements()
{
    run_in $1 mtn st | egrep "^ +(dropped|added|patched|renamed) " | wc -l
}

mtn_content_tag()
{
    run_in $1 cat _MTN/options | tr -d '"' | awk '/branch/ {print $2; }'
}

is_this_mtn()
{
    if [ -d _MTN ] ; then
        return 0
    else
        return 1
    fi
}

#
# subversion
#

svn_find_workspaces()
{
    find . -name ".svn" | while read dot_svn_dir 
    do
        workspace_dir=`dirname $dot_svn_dir`
        if [ ! -d "$workspace_dir/../.svn" ] ; then
            echo "$DIR"
        fi
    done
}

svn_unknown_files() 
{
    run_in $1 svn status | egrep '^\?' | wc -l
}

svn_modified_elements() 
{
    run_in $1 svn status | egrep -v '^\?' | wc -l
}

svn_content_tag()
{
    # ok this is fucked up beyond all recognition!
    # 
    if run_in $1 svn info > /dev/null 2>&1 ; then
        local url=`run_in $1 svn info | awk '/^URL/ {printf $2; }'`
        local repo=`run_in $1 svn info | awk '/^Repository Root/ {printf $3; }'`
        local rev=`run_in $1 svn info | awk '/^Revision/ {printf $2; }'`
        
        local tag=`echo $url | sed -e "s#$repo##"`
        echo "$tag@$rev"
    else
        echo "unknown"
    fi
}

#
# common
#

run_in()
{
    local f=$1
    shift
    ( 
        if [ -z "$QUIET" ] ; then
            echo "avc: "$@" (in $f)" >&2
        fi
        cd $f
        if [ -n "$DRY_RUN" ] ; then
            exit 0
        fi
        "$@"
        exit $? 
    ) 
    return $?
}

potentially_replace()
{
    local file_to_save="$1"
    if [ -f "$file_to_save" ]
    then
        echo "$PNAME: file '$file_to_save' already exists. replacing "         
    fi
    
    cat > "$file_to_save"    
}

#
# avc beef
#

autoinit()
{
    (
        git_search_worskpaces
        mtn_search_workspaces
        svn_find_workspaces        
    ) | potentially_replace avc.conf
        
    echo "found workspaces: "
    cat avc.conf            
}
#
# avc SCM multiplex
#

workspace_type()
{
    local workspace_dir="$1"
    if [ -d "$workspace_dir/_MTN" ] ; then 
        echo "mtn"
    elif [ -d "$workspace_dir/.svn" ] ; then
        echo "svn"
    elif [ -d "$workspace_dir/.git" ] ; then
        echo "git"
    fi
}

available()
{
    if type $1 >/dev/null 2>&1 ; then
        return 0
    else
        return 1
    fi
}

# trampoline METHOD WORKSPACE ...
#
#  checks type of WORKSPACE and then executes
#  type_METHOD WORKSPACE ...
#
trampoline()
{
    local method=$1
    shift    
    local type=`workspace_type $1`    
    if [ -n "$type" ] ; then
        if ! available $type ; then
            echo "n/a"
        else
            ${type}_${method} "$@"
        fi
    else
        echo "$PNAME: unable to execute '$method' on folder '$1"
        exit 1
    fi
}

checkout_url()
{
    local target_folder="$1"
    local url="$2"
    local ref="$3"
    
    if   [[ "$url" = git* ]] ; then
        git_checkout "$target_folder" "$url" "$ref"
    elif [[ "$url" = svn* ]] ; then
        svn_checkout "$target_folder" "$url" "$ref"
    elif [[ "$url" = mtn* ]] ; then
        mtn_checkout "$target_folder" "$url" "$ref"
    else
        echo "avc: unable to checkout "$ref" of "$url"; unknown URL scheme"
        return 1
    fi        
}
remove()
{
    trampoline remove "$@"
}

commit()
{
    trampoline commit "$@"
}
status()
{
    trampoline status "$@"
}

workspace_diff()
{
    trampoline workspace_diff "$@"
}

# trampoline methods
modified_elements()
{
    trampoline modified_elements "$@"
}

content_tag()
{
    trampoline content_tag "$@"
}

unknown_files()
{
    trampoline unknown_files "$@"
}

# generic methods
directory_size()
{
    echo 0
    #du -sh $1 | awk '{print $1;}'
}

latest_modified_file()
{
    find $1 | xargs -d '\n' ls -ld --time-style=+%s | sort -nk6 | tail -n1 |awk '{print $7;}'
}

abspath()
{
    
    if test -z "$1" 
    then
        return
    fi
    
    local dir=`dirname $1`
    local name=`basename $1`
    (
        cd $dir ; 
        echo "`pwd`/$name"
    )
}

find_avc_root()
{
    local potential_avc_root=`pwd`
    while [ "$potential_avc_root" != "/" ]
    do
        if [ -f "$potential_avc_root/avc.conf" ]
        then
            echo "$potential_avc_root"
            return 0
        fi
        if [ -f "$potential_avc_root/.avc.specfile.txt" ]
        then
            echo "$potential_avc_root"
            return 0
        fi
        potential_avc_root=`readlink -f $potential_avc_root/..`      
    done
    return 1
}

find_avc_root_assert()
{
    if ! find_avc_root
    then
        echo "$PNAME: unable to find 'avc.conf' up in directory structure"
        exit 1
    fi    
}

   
all_workspaces()
{
    avc_root=`find_avc_root_assert`
    
    if [ -f "$avc_root/.avc.specfile.txt" ] ; then
        chunks_all $avc_root/.avc.specfile.txt
    else
        cat "$avc_root/avc.conf"
    fi
}

all_workspaces_abs()
{
    for workspace in `all_workspaces` ; do
        abspath $workspace
    done
}

for_all_workspace()
{
    for workspace_dir in `all_workspaces`
    do
        "$@" $workspace_dir
    done
}

match_paths()
(
    local all_workspaces_abs="$(all_workspaces_abs)"
    for path in "$@" ; do
        local path_abs="$(abspath $path)"
        
        for workspace_dir_abs in $all_workspaces_abs ; do
            if echo "$path_abs" | egrep -q "^$workspace_dir_abs" ; then
                echo "$workspace_dir_abs $path_abs"
            fi
        done
    done
)

match_paths_oneline()
{
    match_paths "$@" | (
        local last_workspace=""
        local paths=""
        while read workspace path ; do
            if [ "$workspace" = "$last_workspace" ] ; then
                paths="$paths $path"
            else
                if [ -n "$paths" ] ; then
                    echo "$last_workspace $paths"
                fi
                paths="$path"
            fi
            last_workspace="$workspace"
        done
        if [ -n "$paths" ] ; then
            echo "$last_workspace $paths"
        fi
    )
}

dispatch_to_workspaces()
{
    
    local subaction="$1"    
    shift
    
    if [ -z "$1" ] ; then
        for_all_workspace $subaction
        return
    fi
    
    match_paths_oneline "$@" | while read workspace paths 
    do
        trampoline $subaction $workspace $paths
    done 
}

readonly overall_status_FORMAT="%- 40s %3s %-30s %12s %12s %4s %4s"
readonly overall_staus_DATE_FORMAT="%F"

overall_status_line()
{
    type=`workspace_type $1` 
    if [ -n "$type" ]
    then 
        size=`directory_size $1`
        scm_unknown=`unknown_files $1`
        scm_modified=`modified_elements $1`
        scm_content_tag=`content_tag $1`
        latest_modified=`latest_modified_file $1`
        
        age=`date -r $latest_modified +$overall_staus_DATE_FORMAT`
        printf "$overall_status_FORMAT\n" "$1" "$type" "$scm_content_tag" "$size" "$age" "$scm_modified" "$scm_unknown"
    fi
}

overall_status()
{
    printf "$overall_status_FORMAT\n" directory scm branch/tag size age mod unkn
    echo  "---------------------------------------------------------------------------------------------------------------"
    
    for workspace_dir in $*
    do
        overall_status_line $workspace_dir
    done
}

chunks_all()
{
    local specfile="$1"
    awk '
        /^#/ {
                next;
        }
        // {
                print $1;
        }
        ' $specfile | sort -u
}

chunk_prop()
{
    local specfile="$1"
    local chunk="$2"
    local prop="$3"
    awk '
        /^#/ {
                next;
        }
        /^'${chunk}'[ \t]+'${prop}'[ \t]+/ { 
                print $3;
                found=1;
                exit 0;
        }
        END {
                if( !found)
                exit 1
        }
    ' $specfile
    r=$?
    return $r
}

checkout()
{
    #set -x
    local specfile="$1"
    local target_folder="$2"
    mkdir -p $target_folder    
    for chunk in `chunks_all $specfile` ; do
        local chunk_url=`chunk_prop $specfile $chunk url`
        local chunk_ref=`chunk_prop $specfile $chunk ref`
        echo "$chunk $chunk_url $chunk_ref"
        
        if [ ! -d "$target_folder/$chunk" ] ; then
            checkout_url "$target_folder/$chunk" $chunk_url $chunk_ref
        fi
    done
    cp "$specfile" "$target_folder/.avc.specfile.txt"
}



usage()
{
    echo "usage: $PNAME <action> PATHS"
    echo "agreegated vcs ACTIONs:"
    echo ""
    echo "   st/status         - status in each dir"
    echo "   di/diff           - diff on"
    echo "   rm/remove         - remove files"
    echo "   ci/commit/checkin - commit files"
    echo "   overall_status    - show summary information (path, type, branch, size, modified & unknown files)"
    echo ""
    echo "avc management:"
    echo "   checkout SPECFILE FOLDER"
    echo "                     - creates checkout described by SPECFILE to"
    echo "                       specified FOLDER"
    echo "   autoinit - create initial configuration by digging current"
    echo "              folder"
    echo "options:"
    echo "  -n | --dry-run     - just print commands, don't execute anything"
    echo "  -h | --help | help - print this help message"
    echo "  -m MSG | --message MSG" 
    echo "                     - commit message (for commit action)"
}
PNAME=`basename $0`

#set -x

while [ -n "$1" ] ; do
    if   [ "$1" = "-h" -o "$1" = "--help" ]; then
        usage
        exit 0
    elif [ "$1" = "-n" -o "$1" = "--dry-run" ] ; then
        DRY_RUN=1
        shift
    elif [ "$1" = "-q" -o "$1" = "--quiet" ] ; then
        QUIET=1
        shift
    elif [ "$1" = "-m" -o "$1" = "--message" ] ; then
        if [ -z "$2" ] ; then
            echo "avc: value needed for -m/--message" >&2
            exit 1
        fi
        commit_message="$2"
        shift
        shift
    elif [ "$1" = '--' ] ; then
        shift
        paths="$@"
        break
    else
        if [ -z "$action" ] ; then
            action="$1"
            shift
        else
            paths="$paths $1"
            shift
        fi
    fi
done

if [ -z "$action" ] ; then
    echo "avc: action not specified" >&2
    exit 1
fi

case "$action" in
    help)
        usage
        ;;
    abspath)
        abspath "$*"
        ;;
    checkout)
        
        if [ -z "$paths" ] ; then
            echo "avc: checkout requires specfile and folder" >&2
            exit 1
        fi
        checkout $paths
        ;;
    rm|remove)
        if [ -z "$@" ] ; then
            echo "avc: rm requires paths" >&2
            exit 1
        fi
        dispatch_to_workspaces remove $paths
        ;;
        
    ci|commit|checkin)
        dispatch_to_workspaces commit $paths
        ;;

    diff|di)
        dispatch_to_workspaces workspace_diff $paths
        ;;
        
    status)
        dispatch_to_workspaces status $paths
        ;;
        
    autoinit)
        autoinit
        ;;
        
    overall_status)
        overall_status `all_workspaces`
        ;;
        
    *)
        echo "avc: invalid action '$action'" >&2
        usage
        exit 1
        ;;        
esac

# jedit: :indent=4:tabSize=8:mode=shellscript:

